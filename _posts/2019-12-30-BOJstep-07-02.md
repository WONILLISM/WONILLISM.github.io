---
title: "[BOJ_step_07] 문자열 04 ~ 05"
excerpt: "백준 단계별로 풀기 - 문자열 04 ~ 05"

categories:
    - BOJ_Step
tags:
    - BOJ_step_07
    - 백준
    - 단계별로풀기
    - 알고리즘
    - boj
    - "2675"
    - "1157"
last_modified_at: 2019-12-25
---
# [문자열](https://www.acmicpc.net/step/7)  
문자열을 다루는 문제들을 해결해 보자.  
  
## [문자열 반복(2675)](https://www.acmicpc.net/problem/2675)  
  
[![2675](/assets/BOJ-step/2019-12-30-BOJstep-07-02-img01.jpg)](/assets/BOJ-step/2019-12-30-BOJstep-07-02-img01.jpg)  
  
### 문제풀이  
주어진 문자열에 대해서 각 문자를 r번 반복하여 출력하는 문제이다.  

  
```cpp  
void solution_2675()
{
	char S[21];
	int t, r;
	scanf("%d ", &t);
	while (t--) {
		scanf("%d ", &r);
		scanf("%s", S);
		int i = 0;
		while (S[i]) {
			for (int j = 0; j < r; j++)	printf("%c", S[i]);
			i++;
		}
		printf("\n");
	}
}
```  
  
## [단어공부(1157)](https://www.acmicpc.net/problem/1157)  
  
[![1157](/assets/BOJ-step/2019-12-30-BOJstep-07-02-img02.jpg)](/assets/BOJ-step/2019-12-30-BOJstep-07-02-img02.jpg)  
  
### 문제풀이  
이 문제는 대소문자를 구별하지 않으므로 26크기의 `Alphabet` `0~25`에 `a~z`의 문자를 카운트해준다.  
그리고 그 중 `최빈값`을 찾아주고 `최빈값`이 두 개 이상이면 `?`를 출력하고 한 개라면 해당 문자를 출력해준다.  
  
```cpp  
void solution_1157()
{
	int Alphabet[26];
	char S[1000001];
	int Max = 0, Cnt = 0;
	memset(Alphabet, 0, sizeof(Alphabet));
	scanf("%s", S);
	int a, i = 0;
	while (S[i]) {
		int n = S[i] >= 97 ? S[i] - 97 : S[i] - 65;
		Alphabet[n]++;
		i++;
	}
	for (int j = 0; j < 26; j++)
		if (Max < Alphabet[j])Max = Alphabet[j];
	for (int j = 0; j < 26; j++) {
		if (Alphabet != 0 && Max == Alphabet[j]) {
			Cnt++;
			if (Cnt > 1) {
				printf("?\n");
				return;
			}
			else if (Cnt == 1) a = j;
		}
	}
	printf("%c", a + 65);
}
```  

